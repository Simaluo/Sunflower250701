# Sunflower250701
文本编辑器  
代码结构：代码包含了display.c,editor.h,file_io.c,input.c,teminal.c,text_operations.c和main.c,Makefile共8个文件  
makefile用来编译程序，我这里用了SRCS = $(wildcard *.c)和OBJS = $(SRCS:.c=.o)，可以将所有的.c后缀文件一起编译，方便快捷了很多！  
display.c用于绘制消息和状态栏、更新屏幕、处理滚动偏移。主要作用是画面处理。  
file_io.c用于打开txt文件并读取到编辑器中。主要作用是对目标文件进行提取。  
input.c用于处理用户的输入内容，判断输入的字符或者控制键。  
teminal让用户可以被即时响应每个按键，切换到"原始模式"，编写了disableRawMode和enableRawMode函数。  
text_operations实现了编辑的功能，对文本进行修改、删除等操作。  
editor.h作为一个头文件,可以被多个源文件共享，通过共享，这些源文件可以使用相同的函数声明、常量定义、结构体声明等，保证了代码一致、可复用.  
main就是主函数,我在这里实现了匹配和control键的功能(保存,退出或者搜索),并运行main函数.  

    
刚开始拿到这个题目的时候感觉好难,有点看不懂,花了不少时间去摸索,不过前两个任务还是挺好的,我完成的比较快,后面还是比较难的,但是我还是一步一步摸索出来了,靠着自己的努力和理解
我确实学到了许多,今天很有意义(时间不够了只能先打这么多了,谢谢)

  写在后面:
  对每个问题的理解与分析  
（一）环境搭建与基础设置（Level 0）  
环境搭建是实验的起点，我理解其重要性在于为后续开发提供一个稳定可靠的平台。通过安装必要的工具和配置Makefile，我确保了代码能够在不同环境下顺利编译运行。在实施过程中，我意识到Makefile的编译选项（如-Wall、-Wextra等）对于捕捉潜在的编译问题非常关键，这些选项帮助我在开发早期就避免了许多潜在的代码错误。  
（二）终端原始模式（Level 1）  
终端原始模式的实现是文本编辑器与普通命令行程序的主要区别之一。通过termios结构体控制终端行为，我实现了对用户按键的即时响应。在这一过程中，我深入理解了终端的“熟模式”和“原始模式”的区别，以及如何通过系统调用改变终端模式。错误处理机制的引入让我更加重视程序的鲁棒性，任何系统调用失败都可能导致终端设置异常，进而影响用户正常使用。  
（三）原始输入输出处理（Level 2）  
这一阶段的核心是实现高效的终端输入输出处理。我采用了append buffer的设计模式来优化屏幕刷新，避免闪烁和性能问题。通过封装ANSI转义序列，我实现了光标定位、屏幕清除等基础功能。对于特殊键的处理，我使用了有限状态机的思想，这让我能够清晰地识别和处理不同按键序列，如箭头键的ESC[A、ESC[B等。这一阶段的实现为后续的文本编辑功能打下了坚实的基础。  
（四）文本查看器（Level 3）  
文本查看器的实现标志着从底层输入输出处理向数据模型设计的转变。我选择了行导向的数据结构来存储文本，因为这种结构符合大多数文本编辑操作的模式。在实现过程中，我重点处理了制表符的显示和文本超出视口的显示问题。通过分离渲染逻辑，我确保了原始文本和渲染文本的独立性，这为后续实现语法高亮等功能提供了便利。    
（五）文本编辑器（Level 4）  
这是实验中最具挑战性的部分之一。文本编辑功能的实现需要确保数据一致性。每次编辑操作都涉及到文本内容、光标位置、渲染缓存等多个数据结构的同步更新。我引入了原子操作的概念，确保每个编辑操作要么完全成功，要么完全失败，避免出现中间不一致的状态。脏标志和状态栏的引入为用户提供了直观的反馈，增强了用户体验。同时，我也意识到了内存管理的重要性，特别是在频繁的插入和删除操作中，需要合理分配和释放内存资源。  
（六）文本搜索功能（Level 5）  
文本搜索功能是提高文本编辑器实用性的关键特性之一。实现这一功能需要在效率和用户体验之间找到平衡。增量搜索要求程序能够实时响应用户输入变化并更新搜索结果，这对算法的效率提出了较高的要求。为此，我设计了一个动态更新高亮匹配项的机制，以确保用户能够即时看到搜索结果的变化。循环搜索机制和搜索状态记忆功能则进一步提升了用户操作的便利性。在实现过程中，我重点优化了搜索算法，支持大小写敏感/不敏感选项，并处理了特殊字符与转义序列的问题。  
